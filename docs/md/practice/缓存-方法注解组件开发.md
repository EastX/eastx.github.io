# 缓存 - 方法注解组件开发

作者：EastX
<br/>博客：[https://eastx.github.io/](https://eastx.github.io/)

> 实践是检验真理的唯一标准。


## 需求说明

1. 通过在方法上增加缓存注解，调用方法时根据指定 key 缓存返回数据，再次调用从缓存中获取
2. 可通过注解指定不同的缓存时长
3. 避免缓存雪崩：可支持每个 key 增加随机时长
4. 避免缓存穿透：对于 null 支持短时间存储
5. 避免缓存击穿：缓存失效后限制查库数量


## Spring Cache 整合 Redis 实现

> 利用 Spring Cache 处理 Redis 缓存数据。

#### 时间处理 1 ：配置注入缓存管理器时，根据配置或代码写死指定缓存时长
- yml 配置缓存空间名称与缓存时长对应关系 **`application-custom.yml`**
```yml
# Spring Redis Cache 通过配置处理缓存名称过期时长
# Map 接收，key = 缓存名称，value = 缓存时长，单位秒
expand-cache-config:
    ttl-map: '{"yml-ttl":1000,"hello":2000}'
```
- Redis 配置自定义缓存管理器 **`ExpandRedisConfig.java`**
    <br> 注意开启 Spring Cache 需要在配置类（或启动类）上增加 `@EnableCaching`
```java
// 引入配置
@Value("#{${expand-cache-config.ttl-map:null}}")
private Map<String, Long> ttlMap;
// 注入缓存管理器及处理配置中的缓存时长
@Bean(BEAN_REDIS_CACHE_MANAGER)
public RedisCacheManager expandRedisCacheManager(RedisConnectionFactory factory) {
    /*
        使用 Jackson 作为值序列化处理器
        FastJson 存在部分转换问题如：Set 存储后因为没有对应的类型保存无法转换为 JSONArray（实现 List ） 导致失败
    */
    ObjectMapper om = JsonUtil.createJacksonObjectMapper();
    GenericJackson2JsonRedisSerializer valueSerializer = new GenericJackson2JsonRedisSerializer(om);

    // 配置key、value 序列化（解决乱码的问题）
    RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
            // key 使用 string 序列化方式
            .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(StringRedisSerializer.UTF_8))
            // value 使用 jackson 序列化方式
            .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(valueSerializer))
            // 配置缓存空间名称前缀
            .prefixCacheNameWith("spring:cache:")
            // 配置全局缓存过期时间
            .entryTtl(Duration.ofMinutes(30L));
    // 专门指定某些缓存空间的配置，如果过期时间，这里的 key 为缓存空间名称
    Map<String, RedisCacheConfiguration> configMap = new HashMap<>();
    // 代码写死示例
    configMap.put("world", config.entryTtl(Duration.ofSeconds(60)));
    Set<Map.Entry<String, Long>> entrySet =
            Optional.ofNullable(ttlMap).map(Map::entrySet).orElse(Collections.emptySet());
    for (Map.Entry<String, Long> entry : entrySet) {
        // 指定特定缓存空间对应的过期时间
        configMap.put(entry.getKey(), config.entryTtl(Duration.ofSeconds(entry.getValue())));
    }
    
    RedisCacheWriter redisCacheWriter = RedisCacheWriter.lockingRedisCacheWriter(factory);
    // 使用自定义缓存管理器附带自定义参数随机时间，注意此处为全局设定，5-最小随机秒，30-最大随机秒
    return new ExpandRedisCacheManager(redisCacheWriter, config, configMap, 5, 30);
}
```

#### 时间处理 2 ：利用缓存空间名附带时间，创建缓存处理器时更新缓存时长
- 使用示例：`@Cacheable(cacheNames = "prefix#5m", cacheManager = "expandRedisCacheManager")`
- 自定义 Redis 缓存管理器 **`ExpandRedisCacheManager.java`** 
    <br> 重写创建缓存处理器逻辑，支持缓存空间名称中附带缓存时间根据指定符号分隔
```java
@Override
protected RedisCache createRedisCache(String name, RedisCacheConfiguration cacheConfig) {
    String theName = name;
    if (name.contains(NAME_SPLIT_SYMBOL)) {
        // 名称中存在#标记，修改实际名称，替换默认配置的缓存时长为指定缓存时长
        String[] nameArr = name.split(NAME_SPLIT_SYMBOL);
        theName = nameArr[0];
        Duration duration = TimeUtil.parseDuration(nameArr[1]);
        if (duration != null) {
            cacheConfig = cacheConfig.entryTtl(duration);
        }
    }
    
    // 使用自定义缓存处理器附带自定义参数随机时间，将注入的随机时间传递
    return new ExpandRedisCache(theName, cacheWriter, cacheConfig, minRandomSecond, maxRandomSecond);
}
```

#### 时间处理 3 ：继承缓存处理器执行缓存设置时增加随机时长
- 自定义 Redis 缓存处理器 **`ExpandRedisCache.java`**
    <br> 重写缓存处理器设值逻辑，支持调整配置时长增加随机时间、null 存储短时间
```java
private Duration getDynamicDuration(Object cacheValue) {
    // 如果缓存值为 null，固定返回时长为 30s 避免缓存穿透
    if (NullValue.INSTANCE.equals(cacheValue)) {
        return Duration.ofSeconds(30);
    }
    
    int randomInt = RandomUtil.randomInt(minRandomSecond, maxRandomSecond);
    return cacheConfig.getTtl().plus(Duration.ofSeconds(randomInt));
}
 ```

#### 时间处理 4 ：自定义缓存注解实现通过属性配置时长
- 自定义缓存注解 **`ExpandCacheable.java`**
    - 使用 `@Cacheable` 标识，可支持 Spring Cache 处理
    - 增加 `spelKey()` 支持 SpEL key 生成处理，需要与自定义缓存 key 生成器搭配
    - 增加 `timeout() + unit()` 支持过期时间设置，需要与注入注解的初始化配置方生效
- 自定义缓存 key 生成器 **`ExpandKeyGenerator.java`**
    <br> 与自定义缓存注解 `spelKey()` 搭配处理支持 SpEL key 格式解析，注意使用后初始配置的缓存空间前缀仍会生效 `RedisCacheConfiguration.prefixCacheNameWith("spring:cache:")`
    <br> 插件式，有需要则在 `ExpandRedisConfig` 中进行注入使用
```java
@Override
public Object generate(Object target, Method method, Object... params) {
    ExpandCacheable annotation = AnnotatedElementUtils.findMergedAnnotation(method, ExpandCacheable.class);
    if (Objects.isNull(annotation) || StrUtil.isBlank(annotation.spelKey())) {
        String paramStr = JSONUtil.toJsonStr(params).replace("\"", "");
        return AspectUtil.getMethodKey(target, method, paramStr);
    }
        
    // SpEL 支持
    return AspectUtil.convertSpelValue(annotation.spelKey(), method, params, String.class);
}
```
- 自定义缓存注解过期时间初始化配置类 **`ExpandCacheExpireConfig.java`**
    <br> 利用 Spring Component Bean 获取到使用 `@ExpandCacheable` 注解的方法，利用反射获取注解属性并设置缓存空间过期时间；Map 处理，统一名称缓存空间将会出现替换情景
    <br> 与自定义缓存注解 `timeout() + unit()` 对应处理
    <br> 有需要则在 ExpandRedisConfig 中进行注入
```java
// Spring Bean 加载后，获取所有 @Component 注解的 Bean 判断类中方法是否存在 @SpringCacheable 注解，存在进行过期时间设置
@PostConstruct
public void init() {
    Map<String, Object> beanMap = beanFactory.getBeansWithAnnotation(Component.class);
    if (MapUtil.isEmpty(beanMap)) {
        return;
    }

    beanMap.values().forEach(item ->
        ReflectionUtils.doWithMethods(item.getClass(), method -> {
            ReflectionUtils.makeAccessible(method);
            putConfigTtl(method);
        })
    );

    expandRedisCacheManager.initializeCaches();
}
// 利用反射设置方法注解上配置的过期时间
private void putConfigTtl(Method method) {
    ExpandCacheable annotation = method.getAnnotation(ExpandCacheable.class);
    if (annotation == null) {
        return;
    }

    String[] cacheNames = annotation.cacheNames();
    if (ArrayUtil.isEmpty(cacheNames)) {
        cacheNames = annotation.value();
    }

    // 反射获取缓存管理器初始化配置并设值
    Map<String, RedisCacheConfiguration> initialCacheConfiguration =
            (Map<String, RedisCacheConfiguration>)
                    ReflectUtil.getFieldValue(expandRedisCacheManager, "initialCacheConfiguration");
    RedisCacheConfiguration defaultCacheConfig =
            (RedisCacheConfiguration)
                    ReflectUtil.getFieldValue(expandRedisCacheManager, "defaultCacheConfig");
    Duration ttl = Duration.ofSeconds(annotation.unit().toSeconds(annotation.timeout()));
    for (String cacheName : cacheNames) {
        initialCacheConfiguration.put(cacheName, defaultCacheConfig.entryTtl(ttl));
    }
}
```

**小结**
- 优点
    - 使用 Spring 自带功能，通用性强
- 缺点
    - 针对缓存空间处理缓存时长，缓存时间一致可能导致缓存雪崩，自定义处理需要理解相应源码实现

**参考：**
- [Spring cache整合Redis，并给它一个过期时间！](https://zhuanlan.zhihu.com/p/138295935)
- [让 @Cacheable 可配置 Redis 过期时间](https://juejin.cn/post/7062155187200196644)
- [@Cacheable注解配合Redis设置缓存随机失效时间](https://blog.csdn.net/yang_wen_wu/article/details/120348727)
- [聊聊如何基于spring @Cacheable扩展实现缓存自动过期时间以及自动刷新](https://mp.weixin.qq.com/s/zzJH-enXlLZovV8h0RCR6Q)
- [SpringBoot实现Redis缓存（SpringCache+Redis的整合）](https://blog.csdn.net/user2025/article/details/106595257)


## 自定义 AOP 实现
> 使用 `Spring AOP + 注解` 对方法调用结果进行缓存。

- 方法缓存注解 **`MethodCacheable.java`**
    - 支持不同类型缓存 key： `key() + keyType()`
    - 支持依据条件( SpEL 表达式)设定排除不走缓存： `unless()`
    - 支持缓存 key 自定义过期时长（ Redis 缓存）： `timeout() + unit()`
    - 支持缓存 key 自定义过期时长增加随机时长（ Redis 缓存）： `addRandomDuration()` ，注意固定了随机范围
    - 支持本地缓存设置：`useLocal() + localTimeout()` ，注意本地缓存存在全局最大时长限制
- 方法缓存注解操作类 **`MethodCacheableOperation.java`**
<br> 转换注解为操作对象，AOP 实际使用操作对象进行处理
```java
public static MethodCacheableOperation convert(ProceedingJoinPoint joinPoint) {
    Method method = ((MethodSignature) joinPoint.getSignature()).getMethod();
    MethodCacheable annotation = method.getAnnotation(MethodCacheable.class);
    if (Objects.isNull(annotation)) {
        return null;
    }
        
    Boolean isUnless = AspectUtil.convertSpelValue(annotation.unless(), joinPoint,
        Boolean.class);
    if (Boolean.TRUE.equals(isUnless)) {
        // 匹配条件不满足
        return null;
    }
        
    AspectKeyTypeEnum.KeyTypeData data = AspectKeyTypeEnum.KeyTypeData.builder()
        .prefix("method:cache").key(annotation.key()).build();
    String key = annotation.keyType().obtainTypeKey(joinPoint, data);
    if (StrUtil.isBlank(key)) {
        return null;
    }
        
    Duration duration = Duration.ofSeconds(annotation.unit().toSeconds(annotation.timeout()));
    if (annotation.addRandomDuration()) {
        // 增加随机时长 5 - 30 秒
        duration = duration.plusSeconds(ThreadLocalRandom.current().nextInt(5, 30));
    }
        
    MethodCacheableOperation operation = new MethodCacheableOperation();
    operation.setKey(key);
    operation.setDuration(duration);
    operation.setUseLocal(annotation.useLocal());
    operation.setLocalDuration(annotation.localTimeout());
    return operation;
}
```
- 方法缓存 AOP 处理 **`MethodCacheAspect.java`**
```java
@Around("@annotation(cn.eastx.practice.demo.cache.config.custom.MethodCacheable)")
public Object around(ProceedingJoinPoint joinPoint) throws Throwable {
    MethodCacheableOperation operation = MethodCacheableOperation.convert(joinPoint);
    if (Objects.isNull(operation)) {
        return joinPoint.proceed();
    }
        
    Object result = getCacheData(operation);
    if (Objects.nonNull(result)) {
        return convertCacheData(result);
    }
        
    // 加锁处理同步执行
    synchronized (operation.getKey().intern()) {
        result = getCacheData(operation);
        if (Objects.nonNull(result)) {
            return convertCacheData(result);
        }
        
        result = joinPoint.proceed();
        setDataCache(operation, result);
    }
        
    return result;
}
```

**小结**
- 优点
  - 自定义 Spring AOP 实现，可定制化处理程度较高
  - 支持两级缓存（分布式缓存+本地缓存）
- 缺点
  - 相对于 Spring 自带 Cache ，部分功能存在缺失


## 其他

demo 地址：[https://github.com/EastX/java-practice-demos/tree/main/demo-cache](https://github.com/EastX/java-practice-demos/tree/main/demo-cache)

**推荐阅读：**
- [缓存那些事 - 美团技术团队 明辉](https://tech.meituan.com/2017/03/17/cache-about.html)
- [高并发之缓存 - 开拖拉机的蜡笔小新](https://www.cnblogs.com/xiangkejin/p/9277693.html)

